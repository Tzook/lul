'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const master_services_1 = require("../master/master.services");
const _ = require("underscore");
class MobsServices extends master_services_1.default {
    constructor() {
        super(...arguments);
        this.mobsInfo = new Map();
    }
    generateMobs(mobs) {
        console.log("Generating mobs from data:", mobs);
        let mobModels = [];
        (mobs || []).forEach(mob => {
            let mobId = mob.key;
            let drops = [];
            (mob.drops || []).forEach(drop => {
                let { key, minStack, maxStack } = drop;
                if (minStack >= 1 && maxStack > 1) {
                    drops.push({ key, minStack, maxStack });
                }
                else {
                    drops.push({ key });
                }
            });
            let mobSchema = {
                mobId,
                hp: mob.hp,
                lvl: mob.level,
                exp: mob.exp,
                minDmg: mob.minDMG,
                maxDmg: mob.maxDMG,
                drops,
            };
            let mobModel = new this.Model(mobSchema);
            mobModels.push(mobModel);
        });
        return this.Model.remove({})
            .then(d => this.Model.create(mobModels));
    }
    getMobs() {
        return this.Model.find({}).lean()
            .then((docs) => {
            docs.forEach(doc => {
                this.mobsInfo.set(doc.mobId, doc);
            });
            console.log("got mobs");
            return this.mobsInfo;
        });
    }
    getMobInfo(mobId) {
        return Object.assign({}, this.mobsInfo.get(mobId));
    }
    getMobRoomId(room, mobId) {
        return `${room}-${mobId}`;
    }
    getDamageRange(min, max) {
        return _.random(Math.floor(min) || 1, Math.floor(max));
    }
    getDamageToHurt(hp, dmg) {
        return Math.min(hp, dmg);
    }
    getExp(mob, charDmg) {
        return Math.ceil(mob.exp * (charDmg / mob.dmged));
    }
}
exports.default = MobsServices;
;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NlcnZlci9saWIvbW9icy9tb2JzLnNlcnZpY2VzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFlBQVksQ0FBQzs7QUFDYiwrREFBdUQ7QUFDdkQsZ0NBQWdDO0FBRWhDLGtCQUFrQyxTQUFRLHlCQUFjO0lBQXhEOztRQUNTLGFBQVEsR0FBMkIsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQXNFdEQsQ0FBQztJQXBFTyxZQUFZLENBQUMsSUFBVztRQUM5QixPQUFPLENBQUMsR0FBRyxDQUFDLDRCQUE0QixFQUFFLElBQUksQ0FBQyxDQUFDO1FBRWhELElBQUksU0FBUyxHQUFHLEVBQUUsQ0FBQztRQUVuQixDQUFDLElBQUksSUFBSSxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRztZQUN2QixJQUFJLEtBQUssR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDO1lBRXBCLElBQUksS0FBSyxHQUFHLEVBQUUsQ0FBQztZQUNmLENBQUMsR0FBRyxDQUFDLEtBQUssSUFBSSxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSTtnQkFDN0IsSUFBSSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLEdBQUcsSUFBSSxDQUFDO2dCQUN2QyxFQUFFLENBQUMsQ0FBQyxRQUFRLElBQUksQ0FBQyxJQUFJLFFBQVEsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUNuQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsQ0FBQyxDQUFDO2dCQUN6QyxDQUFDO2dCQUFDLElBQUksQ0FBQyxDQUFDO29CQUNQLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO2dCQUNyQixDQUFDO1lBQ0YsQ0FBQyxDQUFDLENBQUM7WUFFSCxJQUFJLFNBQVMsR0FBYztnQkFDMUIsS0FBSztnQkFDTCxFQUFFLEVBQUUsR0FBRyxDQUFDLEVBQUU7Z0JBQ1YsR0FBRyxFQUFFLEdBQUcsQ0FBQyxLQUFLO2dCQUNkLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRztnQkFDWixNQUFNLEVBQUUsR0FBRyxDQUFDLE1BQU07Z0JBQ2xCLE1BQU0sRUFBRSxHQUFHLENBQUMsTUFBTTtnQkFDbEIsS0FBSzthQUNMLENBQUM7WUFFRixJQUFJLFFBQVEsR0FBRyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDekMsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUMxQixDQUFDLENBQUMsQ0FBQztRQUVILE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7YUFDMUIsSUFBSSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFFTSxPQUFPO1FBQ2IsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBRTthQUMvQixJQUFJLENBQUMsQ0FBQyxJQUFpQjtZQUN2QixJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUc7Z0JBQ2YsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztZQUNuQyxDQUFDLENBQUMsQ0FBQztZQUNILE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDeEIsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDdEIsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRU0sVUFBVSxDQUFDLEtBQWE7UUFFOUIsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDcEQsQ0FBQztJQUVNLFlBQVksQ0FBQyxJQUFZLEVBQUUsS0FBYTtRQUM5QyxNQUFNLENBQUMsR0FBRyxJQUFJLElBQUksS0FBSyxFQUFFLENBQUM7SUFDM0IsQ0FBQztJQUVNLGNBQWMsQ0FBQyxHQUFXLEVBQUUsR0FBVztRQUM3QyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDeEQsQ0FBQztJQUVNLGVBQWUsQ0FBQyxFQUFVLEVBQUUsR0FBVztRQUM3QyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDMUIsQ0FBQztJQUVTLE1BQU0sQ0FBQyxHQUFpQixFQUFFLE9BQWU7UUFFNUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLE9BQU8sR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUN0RCxDQUFDO0NBQ0o7QUF2RUQsK0JBdUVDO0FBQUEsQ0FBQyIsImZpbGUiOiJsaWIvbW9icy9tb2JzLnNlcnZpY2VzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IE1hc3RlclNlcnZpY2VzIGZyb20gJy4uL21hc3Rlci9tYXN0ZXIuc2VydmljZXMnO1xuaW1wb3J0ICogYXMgXyBmcm9tIFwidW5kZXJzY29yZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2JzU2VydmljZXMgZXh0ZW5kcyBNYXN0ZXJTZXJ2aWNlcyB7XG5cdHByaXZhdGUgbW9ic0luZm86IE1hcDxzdHJpbmcsIE1PQl9NT0RFTD4gPSBuZXcgTWFwKCk7XG5cblx0cHVibGljIGdlbmVyYXRlTW9icyhtb2JzOiBhbnlbXSk6IFByb21pc2U8YW55PiB7XG5cdFx0Y29uc29sZS5sb2coXCJHZW5lcmF0aW5nIG1vYnMgZnJvbSBkYXRhOlwiLCBtb2JzKTtcblx0XHRcblx0XHRsZXQgbW9iTW9kZWxzID0gW107XG5cblx0XHQobW9icyB8fCBbXSkuZm9yRWFjaChtb2IgPT4ge1xuXHRcdFx0bGV0IG1vYklkID0gbW9iLmtleTtcblxuXHRcdFx0bGV0IGRyb3BzID0gW107XG5cdFx0XHQobW9iLmRyb3BzIHx8IFtdKS5mb3JFYWNoKGRyb3AgPT4ge1xuXHRcdFx0XHRsZXQgeyBrZXksIG1pblN0YWNrLCBtYXhTdGFjayB9ID0gZHJvcDtcblx0XHRcdFx0aWYgKG1pblN0YWNrID49IDEgJiYgbWF4U3RhY2sgPiAxKSB7XG5cdFx0XHRcdFx0ZHJvcHMucHVzaCh7IGtleSwgbWluU3RhY2ssIG1heFN0YWNrIH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRyb3BzLnB1c2goeyBrZXkgfSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRsZXQgbW9iU2NoZW1hOiBNT0JfTU9ERUwgPSB7XG5cdFx0XHRcdG1vYklkLFxuXHRcdFx0XHRocDogbW9iLmhwLFxuXHRcdFx0XHRsdmw6IG1vYi5sZXZlbCxcblx0XHRcdFx0ZXhwOiBtb2IuZXhwLFxuXHRcdFx0XHRtaW5EbWc6IG1vYi5taW5ETUcsXG5cdFx0XHRcdG1heERtZzogbW9iLm1heERNRyxcblx0XHRcdFx0ZHJvcHMsXG5cdFx0XHR9O1xuXG5cdFx0XHRsZXQgbW9iTW9kZWwgPSBuZXcgdGhpcy5Nb2RlbChtb2JTY2hlbWEpO1xuXHRcdFx0bW9iTW9kZWxzLnB1c2gobW9iTW9kZWwpO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHRoaXMuTW9kZWwucmVtb3ZlKHt9KVxuXHRcdFx0LnRoZW4oZCA9PiB0aGlzLk1vZGVsLmNyZWF0ZShtb2JNb2RlbHMpKTtcblx0fVxuXG5cdHB1YmxpYyBnZXRNb2JzKCk6IFByb21pc2U8TWFwPHN0cmluZywgTU9CX01PREVMPj4ge1xuXHRcdHJldHVybiB0aGlzLk1vZGVsLmZpbmQoe30pLmxlYW4oKVxuXHRcdFx0LnRoZW4oKGRvY3M6IE1PQl9NT0RFTFtdKSA9PiB7XG5cdFx0XHRcdGRvY3MuZm9yRWFjaChkb2MgPT4ge1xuXHRcdFx0XHRcdHRoaXMubW9ic0luZm8uc2V0KGRvYy5tb2JJZCwgZG9jKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiZ290IG1vYnNcIik7XG5cdFx0XHRcdHJldHVybiB0aGlzLm1vYnNJbmZvO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRwdWJsaWMgZ2V0TW9iSW5mbyhtb2JJZDogc3RyaW5nKTogTU9CX01PREVMIHtcblx0XHQvLyBhbHdheXMgcmV0dXJuIGEgY29weSBvZiB0aGUgbW9iLCBzbyBpdCBjYW4gYmUgbW9kaWZpZWQgZnJlZWx5XG5cdFx0cmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRoaXMubW9ic0luZm8uZ2V0KG1vYklkKSk7XG5cdH1cblxuXHRwdWJsaWMgZ2V0TW9iUm9vbUlkKHJvb206IHN0cmluZywgbW9iSWQ6IHN0cmluZyk6IHN0cmluZyB7XG5cdFx0cmV0dXJuIGAke3Jvb219LSR7bW9iSWR9YDtcblx0fVxuXG5cdHB1YmxpYyBnZXREYW1hZ2VSYW5nZShtaW46IG51bWJlciwgbWF4OiBudW1iZXIpOiBudW1iZXIge1xuXHRcdHJldHVybiBfLnJhbmRvbShNYXRoLmZsb29yKG1pbikgfHwgMSwgTWF0aC5mbG9vcihtYXgpKTtcblx0fVxuXG5cdHB1YmxpYyBnZXREYW1hZ2VUb0h1cnQoaHA6IG51bWJlciwgZG1nOiBudW1iZXIpOiBudW1iZXIge1xuXHRcdHJldHVybiBNYXRoLm1pbihocCwgZG1nKTtcblx0fVxuXG4gICAgcHVibGljIGdldEV4cChtb2I6IE1PQl9JTlNUQU5DRSwgY2hhckRtZzogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgLy8gd2Ugcm91bmQgdGhlIGV4cCB1cCBmb3IgdGhlIGNoYXJhY3RlciA6KVxuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG1vYi5leHAgKiAoY2hhckRtZyAvIG1vYi5kbWdlZCkpO1xuICAgIH1cbn07Il19
